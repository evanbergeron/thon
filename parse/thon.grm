structure A = Ast

%%
%header (functor ThonLrValsFn (structure Token : TOKEN))

%eop EOF

%term
   EOF
 | ZERO
 | SUCC
 | LPAREN | RPAREN
 | PIPE
 | LAM
 | SARROW
 | COLON
 | NAT
 | REC
 | APP
 | IDX of int
 | ID of string
 | GO
 | POLY
 | LEFT
 | RIGHT
 | FST
 | SND
 | COMMA
 | STAR
 | ALL
 | SOME
 | TYPEREC
 | DOT
 | UNIT
 | FOLD
 | UNFOLD
 | WITH
 | IMPL
 | AS
 | USE
 | IN
 | CASE
 | OF

%nonterm
   exp of A.Exp
 | typ of A.Typ
 | program of A.Exp

%verbose
%pos int
%start exp (* i think likely this should be program, but I really dont like that hack *)
%eop EOF

%name Thon

(* Each rule is then assigned the precedence of its rightmost terminal *)
(* If the rule has the higher precedence, the reduction is chosen. *)

(* The precedence grows down *)
%nonassoc EOF ZERO SUCC LPAREN RPAREN LAM COLON NAT IDX ID REC PIPE POLY COMMA STAR LEFT RIGHT FST SND ALL SOME TYPEREC DOT UNIT FOLD UNFOLD WITH AS USE IN CASE OF IMPL
%right SARROW
%nonassoc APP GO (* Deliberately last *)

%%

(* program: *)
(*     GO exp (exp) *)

exp:
    LPAREN exp RPAREN (exp)
  | exp exp %prec APP (A.App(exp1, exp2))
  | exp typ %prec APP (A.TypApp(typ, exp))
  | ID (A.Var (ID, ~1))
  | ZERO (A.Zero)
  | SUCC exp (A.Succ exp)
  | UNIT (A.TmUnit)
  (* eventually would rather this be LAM ID COLON typ SARROW exp but
   * not until we manage to turn names into binding site indexes *)
  | LAM ID COLON typ SARROW exp (A.Lam (ID, typ, exp))
  | LAM typ SARROW exp (A.Lam("TODO", typ, exp)) (* TODO deprecate *)
  | REC exp LPAREN ZERO SARROW exp PIPE SUCC ID SARROW exp RPAREN (A.Rec (exp1, exp2, ID, exp3))
  | POLY exp (A.TypAbs exp)
  | LPAREN exp COMMA exp RPAREN (A.Tuple(exp1, exp2))
  | FST exp (A.ProdLeft exp)
  | SND exp (A.ProdRight exp)
  | LEFT exp COLON typ (A.PlusLeft(typ, exp))
  | RIGHT exp COLON typ (A.PlusRight(typ, exp))
  | FOLD typ WITH exp (A.Fold(typ, exp))
  (* impl reprType in pkgImpl as pkgType *)
  (* Impl (reprType, pkgImpl, pkgType) *)
  | IMPL typ WITH typ AS exp (A.Impl(typ2, exp, typ1))
  | USE exp AS ID IN exp (A.Use(exp1, ID, exp2)) (* TODO still need type name *)
  | CASE exp OF ID SARROW exp PIPE ID SARROW exp (A.Case(exp1, ID1, exp2, ID2, exp3))

typ:
    NAT (A.Nat)
  | UNIT (A.Unit)
  | typ SARROW typ (A.Arr(typ1, typ2))
  | typ STAR typ (A.Prod(typ1, typ2))
  | LPAREN typ RPAREN (typ)
  | IDX (A.TypVar IDX)
  | ALL typ (A.All typ) (* TODO maybe have a dot *)
  | SOME typ (A.Some typ) (* TODO maybe have a dot *)
  | TYPEREC DOT typ (A.TyRec typ)
  (* TODO should this take precedence below star and arrow? *)
  | typ PIPE typ (A.Plus (typ1, typ2))
