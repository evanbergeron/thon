structure A = Ast

%%
%header (functor ThonLrValsFn (structure Token : TOKEN))

%eop EOF

%term
   EOF
 | ZERO
 | SUCC
 | LPAREN | RPAREN
 | PIPE
 | LAM
 | SARROW
 | COLON
 | NAT
 | REC
 | APP
 | IDX of int
 | GO
 | POLY
 | LEFT
 | RIGHT
 | FST
 | SND
 | COMMA
 | STAR
 | ALL
 | SOME
 | TYPEREC
 | DOT
 | UNIT
 | FOLD
 | UNFOLD
 | WITH
 | PACK
 | IMPL
 | AS
 | OPEN
 | IN
 | CASE
 | OF

%nonterm
   exp of A.Exp
 | typ of A.Typ
 | program of A.Exp

%verbose
%pos int
%start exp (* i think likely this should be program, but I really dont like that hack *)
%eop EOF

%name Thon

(* Each rule is then assigned the precedence of its rightmost terminal *)
(* If the rule has the higher precedence, the reduction is chosen. *)

(* The precedence grows down *)
%nonassoc EOF ZERO SUCC LPAREN RPAREN LAM COLON NAT IDX REC PIPE POLY COMMA STAR LEFT RIGHT FST SND ALL SOME TYPEREC DOT UNIT FOLD UNFOLD WITH PACK AS OPEN IN CASE OF IMPL
%right SARROW
%nonassoc APP GO (* Deliberately last *)

%%

(* program: *)
(*     GO exp (exp) *)

exp:
    LPAREN exp RPAREN (exp)
  | exp exp %prec APP (A.App(exp1, exp2))
  | exp typ %prec APP (A.TypApp(typ, exp))
  | IDX (A.Var IDX)
  | ZERO (A.Zero)
  | SUCC exp (A.Succ exp)
  | UNIT (A.TmUnit)
  (* eventually would rather this be LAM ID COLON typ SARROW exp but
   * not until we manage to turn names into binding site indexes *)
  | LAM typ SARROW exp (A.Lam (typ, exp))
  | REC exp LPAREN ZERO SARROW exp PIPE SUCC SARROW exp RPAREN (A.Rec (exp1, exp2, exp3))
  | POLY exp (A.TypAbs exp)
  | LPAREN exp COMMA exp RPAREN (A.Tuple(exp1, exp2))
  | FST exp (A.ProdLeft exp)
  | SND exp (A.ProdRight exp)
  | LEFT exp COLON typ (A.PlusLeft(typ, exp))
  | RIGHT exp COLON typ (A.PlusRight(typ, exp))
  | FOLD typ WITH exp (A.Fold(typ, exp))
  (* pack reprType in pkgImpl as pkgType *)
  | IMPL typ WITH exp AS typ (A.Pack(typ1, exp, typ2))
  | OPEN exp IN exp (A.Open(exp1, exp2))
  | CASE exp OF exp PIPE exp (A.Case(exp1, exp2, exp3))

typ:
    NAT (A.Nat)
  | UNIT (A.Unit)
  | typ SARROW typ (A.Arr(typ1, typ2))
  | typ STAR typ (A.Prod(typ1, typ2))
  | LPAREN typ RPAREN (typ)
  | IDX (A.TypVar IDX)
  | ALL typ (A.All typ) (* TODO maybe have a dot *)
  | SOME typ (A.Some typ) (* TODO maybe have a dot *)
  | TYPEREC DOT typ (A.TyRec typ)
  (* TODO should this take precedence below star and arrow? *)
  | typ PIPE typ (A.Plus (typ1, typ2))
